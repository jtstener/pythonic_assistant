"""
Author: Julius Stener
Created: 12/3/23
Description: This file should be throught of as the interface with the OpenAI API.
  This file is explicitly not intended to be a wrapper and does not handle any of
  the execution.
"""

# imports
from pythonic_assistant.openai_wrappers.docs_parser import DocsParser

# import the log
from _log.log import Log
log = Log(log_name=__name__)

# constants
MAX_TOOLS = 128

class AssistantsWrapper():
  """
  AssistantsWrapper serves as a clean way to interact with the OpenAI Assistants API.
  """

  def __init__(self, client, **kwargs):
    """
    Initializes the AssistantsWrapper class
    """
    self.client = client
    self.parser = DocsParser(client)

    self.name = "Helpful Assistant"
    self.description = ""
    self.instructions = "You are a helpful assistant."
    self.tools = []
    self.model = "gpt-4-1106-preview"
    self.file_ids = []
    self.metadata = ""
    self.survive = False

    self.handle_kwargs(**kwargs)

    self.functions = {}  # registry of actual tools

    self.assistant = self.client.beta.assistants.create(
        name=self.name,
        description=self.description,
        instructions=self.instructions,
        tools=self.tools,
        model=self.model,
        file_ids=self.file_ids,
        metadata=self.metadata,
    )
    log.info(f"Assistant Initialized: {self.assistant.id}")

  def update(self, **kwargs):
    """
    Updates the assistant
    """
    self.handle_kwargs(**kwargs)

    self.assistant = self.client.beta.assistants.update(
        self.assistant.id,
        name=self.name,
        description=self.description,
        instructions=self.instructions,
        tools=self.tools,
        model=self.model,
        file_ids=self.file_ids,
        metadata=self.metadata,
    )
    log.info(f"Updated Assistant: {self.assistant.id}")

  def handle_kwargs(self, **kwargs):
    """
    Manage all the kwargs for the Assistant in one function
    """
    self.name = kwargs.get("name", self.name)
    self.description = kwargs.get("description", self.description)
    self.instructions = kwargs.get("instructions", self.instructions)
    self.tools = kwargs.get("tools", self.tools)
    self.model = kwargs.get("model", self.model)
    self.file_ids = kwargs.get("file_ids", self.file_ids)
    self.metadata = kwargs.get("metadata", self.metadata)
    self.survive = kwargs.get("survive_on_exit", self.survive)

  def get_id(self) -> str:
    """
    Returns the assistant id
    """
    return self.assistant.id

  def add_tool(self, func) -> None:
    """
    Add a tool to the Assistant
    """
    if len(self.tools) >= MAX_TOOLS:
      log.error(f"Max Tools Reached: {self.assistant.id}")
      raise Exception(
          "Maximum Tools Reached: Please remove a tool to add another one."
          )

    name, func_json = self.parser.parse(func)
    self.functions[name] = func
    self.tools.append(func_json)
    self.update()

  def add_tools(self, funcs: list) -> None:
    """
    Add multiple tools at once from a list of functions
    """
    for func in funcs:
      self.add_tool(func)

  def add_tool_from_gpt(
      self,
      tool_name,
      description,
      parameters,
      required_parameters,
      func
      ):
    """
    Add a single tool to the Assistant that was generated by the GPT
    """
    if len(self.tools) >= MAX_TOOLS:
      log.error(f"Max Tools Reached: {self.assistant.id}")
      raise Exception(
          "Maximum Tools Reached: Please remove a tool to add another one."
          )
    
    func_json = {
      'name': tool_name,
      'description': description,
      'parameters': parameters,
      'required': required_parameters
    }

    func_json = {'type': 'function', 'function': function}

    self.functions[tool_name] = func
    self.tools.append(func_json)
    self.update()

  def get_tool(self, tool_name: str):
    """
    Retreive a tool based on its tool name. If that tool does not
      exist, a function is returned that raises an exception.
    """
    try:
      return self.functions[tool_name]
    except KeyError as e:
      def func(*args, **kwargs):
        raise Exception(f"No Tool Function With Name{tool_name}")
      return func

  def remove_tool(self, tool_name: str):
    """
    Remove a tool based on its tool name
    """
    pass

  def delete_assistant(self):
    """
    Delete the assistant. This should probably only happen on exit.
    """
    id = self.assistant.id
    response = self.client.beta.assistants.delete(id)
    if not response.deleted:
      log.error(f"Failed to Delete Assistant: {id}")
      raise Exception("Assistant has not been deleted")
    log.info(f"Deleted Assistant: {id}")
